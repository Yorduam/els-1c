// Проверка студента на наличии в другой группе
Функция ПроверкаСтудентаВГруппе(СтрокаСтудента) Экспорт
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	АктуальностьКонтингентаСрезПоследних.Обучающийся КАК Обучающийся,
	|	АктуальностьКонтингентаСрезПоследних.Группа КАК Группа,
	|	АктуальностьКонтингентаСрезПоследних.Обучается КАК Обучается
	|ИЗ
	|	РегистрСведений.АктуальностьКонтингента.СрезПоследних КАК АктуальностьКонтингентаСрезПоследних
	|ГДЕ
	|	АктуальностьКонтингентаСрезПоследних.Обучающийся = &ФИО");
	
	Запрос.УстановитьПараметр("ФИО", СтрокаСтудента);
	
	Результат = Запрос.Выполнить().Выбрать();
	Если Результат.Следующий() Тогда
		Если Результат.Обучается = Истина Тогда
			Сообщить("Студент " + СтрокаСтудента + " уже в группе " + Результат.Группа.Наименование);
			Отказ = Истина
		КонецЕсли;
	КонецЕсли;
	
	Возврат Отказ;
КонецФункции

// Подсчитывает количество обучающихся при зачислении, переводе или отчислении
//
// Параметры:
//	Абитуриенты - ТабличнаяЧасть - табличная часть документа со списком обучающихся и групп.
//	Режим - выбор вида операции (обычный, отчисление, зачисление).
//		обычный - простой подсчет обучающихся по группе;
//		отчисление - подсчет обучающихся при переводе (убрать из группы);
//		зачисление - подсчет обучающихся при переводе (добавить в группу).
//
// Возвращаемое значение
//	ТаблицаЗначений - таблица значений с группой, общей численностью и численностью бюджетников и внебюджетников
//
// Пример:
//	ТЗ = РаботаДокументов.РасчетЧисленности(Объект.Абитуриенты, "зачисление");
//
Функция РасчетЧисленности(Абитуриенты, Режим) Экспорт
	// подсчет группы с уточнением количества бюджета и внебюджета
	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("Группа");
	ТЗ.Колонки.Добавить("Количество");
	ТЗ.Колонки.Добавить("Бюджет");
	ТЗ.Колонки.Добавить("Внебюджет");
	
	// простой подсчет обучающихся
	Если Режим = "обычный" Тогда
		// проход по каждой строка табличной части
		Для Каждого ТекСтрокаАбитуриенты Из Абитуриенты Цикл
			// поиск группы в таблице значений
			Индекс = ТЗ.Найти(ТекСтрокаАбитуриенты.Группа, "Группа");
			// если группа найдена
			Если Индекс = 1 Тогда
				// выгрузка строки таблицы значений и добавление обучающегося
				Строка = ТЗ.Получить(Индекс);
				Строка.Количество = Строка.Количество + 1;
				
				// проверка на бюджет и внебюджет
				Если ТекСтрокаАбитуриенты.ФИО.Внебюджет = Истина Тогда
					Строка.Внебюджет = Строка.Внебюджет + 1;
				Иначе
					Строка.Бюджет = Строка.Бюджет + 1;
				КонецЕсли;
				
			// если группа не найдена
			Иначе
				// добавление новой строки с добавлением студента
				Строка = ТЗ.Добавить();
				Строка.Группа = ТекСтрокаАбитуриенты.Группа;
				Строка.Количество = 1;
				
				// проверка на бюджет и внебюджет
				Если ТекСтрокаАбитуриенты.ФИО.Внебюджет = Истина Тогда
					Строка.Внебюджет = 1;
					Строка.Бюджет = 0;
				Иначе
					Строка.Внебюджет = 0;
					Строка.Бюджет = 1;
				КонецЕсли;
				
			КонецЕсли;
		КонецЦикла;
		
		Возврат ТЗ;
		
	// подсчет обучающихся для удаления при переводе
	ИначеЕсли Режим = "отчисление" Тогда
		// проход по каждой строка табличной части
		Для Каждого ТекСтрокаАбитуриенты Из Абитуриенты Цикл
			// поиск группы в таблице значений
			Индекс = ТЗ.Найти(ТекСтрокаАбитуриенты.СтараяГруппа, "Группа");
			// если группа найдена
			Если Индекс = 1 Тогда
				// выгрузка строки таблицы значений и добавление обучающегося
				Строка = ТЗ.Получить(Индекс);
				Строка.Количество = Строка.Количество + 1;
				
				// проверка на бюджет и внебюджет
				Если ТекСтрокаАбитуриенты.ФИО.Внебюджет = Истина Тогда
					Строка.Внебюджет = Строка.Внебюджет + 1;
				Иначе
					Строка.Бюджет = Строка.Бюджет + 1;
				КонецЕсли;
				
			// если группа не найдена
			Иначе
				// добавление новой строки с добавлением студента
				Строка = ТЗ.Добавить();
				Строка.Группа = ТекСтрокаАбитуриенты.СтараяГруппа;
				Строка.Количество = 1;
				
				// проверка на бюджет и внебюджет
				Если ТекСтрокаАбитуриенты.ФИО.Внебюджет = Истина Тогда
					Строка.Внебюджет = 1;
					Строка.Бюджет = 0;
				Иначе
					Строка.Внебюджет = 0;
					Строка.Бюджет = 1;
				КонецЕсли;
				
			КонецЕсли;
		КонецЦикла;
		
		Возврат ТЗ;
		
	// подсчет обучающихся для добавления при переводе
	ИначеЕсли Режим = "зачисление" Тогда
		// проход по каждой строка табличной части
		Для Каждого ТекСтрокаАбитуриенты Из Абитуриенты Цикл
			// поиск группы в таблице значений
			Индекс = ТЗ.Найти(ТекСтрокаАбитуриенты.НоваяГруппа, "Группа");
			// если группа найдена
			Если Индекс = 1 Тогда
				// выгрузка строки таблицы значений и добавление обучающегося
				Строка = ТЗ.Получить(Индекс);
				Строка.Количество = Строка.Количество + 1;
				
				// проверка на бюджет и внебюджет
				Если ТекСтрокаАбитуриенты.ФИО.Внебюджет = Истина Тогда
					Строка.Внебюджет = Строка.Внебюджет + 1;
				Иначе
					Строка.Бюджет = Строка.Бюджет + 1;
				КонецЕсли;
				
			// если группа не найдена
			Иначе
				// добавление новой строки с добавлением студента
				Строка = ТЗ.Добавить();
				Строка.Группа = ТекСтрокаАбитуриенты.НоваяГруппа;
				Строка.Количество = 1;
				
				// проверка на бюджет и внебюджет
				Если ТекСтрокаАбитуриенты.ФИО.Внебюджет = Истина Тогда
					Строка.Внебюджет = 1;
					Строка.Бюджет = 0;
				Иначе
					Строка.Внебюджет = 0;
					Строка.Бюджет = 1;
				КонецЕсли;
				
			КонецЕсли;
		КонецЦикла;
		
		Возврат ТЗ;
		
	КонецЕсли;
КонецФункции

// Рубрика "ДолгийЯщик"
Функция ПолучитьИдентификаторыДанных(тДанные, стрПоляВертикальныхГруппировок) Экспорт
	
	тИдентификаторыКолонок = тДанные.Скопировать(,стрПоляВертикальныхГруппировок);
	тИдентификаторыКолонок.Свернуть(стрПоляВертикальныхГруппировок);
	
	тИдентификаторыКолонок.Колонки.Добавить("Имя");
	тИдентификаторыКолонок.Колонки.Добавить("Заголовок");
	тИдентификаторыКолонок.Колонки.Добавить("Тип"); //("ТипЗначения")
	
	Для сч = 1 по тИдентификаторыКолонок.Количество() Цикл
		тИдентификаторыКолонок[сч-1].Имя = "Группировка_" + Формат(сч, "ЧЦ=5; ЧВН=; ЧГ=0");
	КонецЦикла;
	
	Возврат тИдентификаторыКолонок;
	
КонецФункции

Функция ТрансформироватьДанныеВКроссТаблицу(тДанные, тИдентификаторыКолонок, стрГоризонтальныеГруппировки, ИмяКолонкиРесурс) Экспорт
	
	тКроссТаблица = тДанные.Скопировать(,стрГоризонтальныеГруппировки);
	тКроссТаблица.Свернуть(стрГоризонтальныеГруппировки);
	
	Для каждого Строка из тИдентификаторыКолонок Цикл
		тКроссТаблица.Колонки.Добавить(Строка.Имя, Строка.Тип, Строка.Заголовок); //Строка.ТипЗначения
	КонецЦикла;
	
	СтруктураПоискаВертикальныхГруппировок = Новый Структура;
	Для каждого Колонка из тИдентификаторыКолонок.Колонки Цикл
		Если Колонка.Имя = "Имя" Тогда
			Продолжить;
		ИначеЕсли Колонка.Имя = "Заголовок" Тогда
			Продолжить;
		ИначеЕсли Колонка.Имя = "Тип" Тогда //"ТипЗначения"
			Продолжить;
		КонецЕсли;
		
		СтруктураПоискаВертикальныхГруппировок.Вставить(Колонка.Имя);
		
	КонецЦикла;
	
	СтруктураПоискаГоризонтальныхГруппировок = Новый Структура(стрГоризонтальныеГруппировки);
	
	Для Каждого Строка Из тДанные Цикл
		
		ЗаполнитьЗначенияСвойств(СтруктураПоискаГоризонтальныхГруппировок, Строка);
		НайденныеСтроки = тКроссТаблица.НайтиСтроки(СтруктураПоискаГоризонтальныхГруппировок);
		Если НайденныеСтроки.Количество() Тогда
			СтрокаОтображения = НайденныеСтроки[0];
		Иначе
			СтрокаОтображения = тКроссТаблица.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаОтображения, СтруктураПоискаГоризонтальныхГруппировок);
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(СтруктураПоискаВертикальныхГруппировок, Строка);
		НайденныеСтроки = тИдентификаторыКолонок.НайтиСтроки(СтруктураПоискаВертикальныхГруппировок);
		ИмяКолонкиОтображения = НайденныеСтроки[0].Имя; // найденное значение ВСЕГДА будет. Если нет, то это несоблюдение требований алгоритма. Выдаем программную ошибку
			
		СтрокаОтображения[ИмяКолонкиОтображения] = Строка[ИмяКолонкиРесурс];
	КонецЦикла;
	
	Возврат тКроссТаблица;
	
КонецФункции

Функция ТрансформироватьКроссТаблицуВДанные(тКроссТаблица, тИдентификаторыКолонок, ИмяКолонкиРесурс) Экспорт
	
	тДанные = Новый ТаблицаЗначений;
	тДанные.Колонки.Добавить(ИмяКолонкиРесурс);
	
	Для каждого Колонка из тКроссТаблица.Колонки Цикл
		Если Найти(Колонка.Имя, "Группировка_") = 1 Тогда
			Продолжить;
		КонецЕсли;
		
		тДанные.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	Для каждого Колонка из тИдентификаторыКолонок.Колонки Цикл
		Если Колонка.Имя = "Имя" Тогда
			Продолжить;
		ИначеЕсли Колонка.Имя = "Заголовок" Тогда
			Продолжить;
		КонецЕсли;
		
		тДанные.Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	
	Для каждого КолонкаОтображения из тКроссТаблица.Колонки Цикл
		Если НЕ Найти(КолонкаОтображения.Имя, "Группировка_") = 1 Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаСоответствияКолонок = тИдентификаторыКолонок.Найти(КолонкаОтображения.Имя, "Имя"); // Строка должна быть найдена ВСЕГДА. Иначе это несоблюдение требований алгоритма - будет выдана программная ошибка
		
		Для каждого СтрокаОтображения из тКроссТаблица Цикл
			
			Значение = СтрокаОтображения[КолонкаОтображения.Имя];
			Если НЕ ЗначениеЗаполнено(Значение) Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока = тДанные.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаОтображения);
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаСоответствияКолонок);
			НоваяСтрока[ИмяКолонкиРесурс] = Значение;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат тДанные;
	
КонецФункции